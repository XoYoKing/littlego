// -----------------------------------------------------------------------------
// Copyright 2015 Patrick NÃ¤f (herzbube@herzbube.ch)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// -----------------------------------------------------------------------------


// Project includes
#import "AutoLayoutUtility.h"
#import "../shared/LayoutManager.h"


@implementation AutoLayoutUtility

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a superview that specify that
/// @a subview completely fills @a superview, i.e. that the subview's frame is
/// the same as the superview's bounds. Returns the constraints generated by
/// this method.
// -----------------------------------------------------------------------------
+ (NSArray*) fillSuperview:(UIView*)superview
               withSubview:(UIView*)subview
{
  return [AutoLayoutUtility fillSuperview:superview
                              withSubview:subview
                                  margins:UIEdgeInsetsMake(0, 0, 0, 0)];
}

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a superview that specify that
/// @a subview completely fills @a superview except for the specified margins.
/// Returns the constraints generated by this method.
// -----------------------------------------------------------------------------
+ (NSArray*) fillSuperview:(UIView*)superview
               withSubview:(UIView*)subview
                   margins:(UIEdgeInsets)margins
{
  NSDictionary* viewsDictionary = [NSDictionary dictionaryWithObject:subview
                                                              forKey:@"subview"];
  NSArray* visualFormats = [NSArray arrayWithObjects:
                            [NSString stringWithFormat:@"H:|-%f-[subview]-%f-|", margins.left, margins.right],
                            [NSString stringWithFormat:@"V:|-%f-[subview]-%f-|", margins.top, margins.bottom],
                            nil];
  return [AutoLayoutUtility installVisualFormats:visualFormats
                                       withViews:viewsDictionary
                                          inView:superview];
}

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a superview that specify that
/// @a subview completely fills the area between the layout guides of
/// @a superview. Returns the constraints generated by this method.
// -----------------------------------------------------------------------------
+ (NSArray*) fillAreaBetweenLayoutGuidesOfSuperview:(UIView*)superview
                                        withSubview:(UIView*)subview
{
  NSLayoutXAxisAnchor* leftAnchor;
  NSLayoutXAxisAnchor* rightAnchor;
  NSLayoutYAxisAnchor* topAnchor;
  NSLayoutYAxisAnchor* bottomAnchor;
  UIView* anchorView = superview;
  if (@available(iOS 11.0, *))
  {
    UILayoutGuide* layoutGuide = anchorView.safeAreaLayoutGuide;
    leftAnchor = layoutGuide.leftAnchor;
    rightAnchor = layoutGuide.rightAnchor;
    topAnchor = layoutGuide.topAnchor;
    bottomAnchor = layoutGuide.bottomAnchor;
  }
  else
  {
    leftAnchor = anchorView.leftAnchor;
    rightAnchor = anchorView.rightAnchor;
    topAnchor = anchorView.topAnchor;
    bottomAnchor = anchorView.bottomAnchor;
  }

  NSLayoutConstraint* leftAnchorConstraint = [subview.leftAnchor constraintEqualToAnchor:leftAnchor constant:0];
  NSLayoutConstraint* rightAnchorConstraint = [subview.rightAnchor constraintEqualToAnchor:rightAnchor constant:0];
  NSLayoutConstraint* topAnchorConstraint = [subview.topAnchor constraintEqualToAnchor:topAnchor constant:0];
  NSLayoutConstraint* bottomAnchorConstraint = [subview.bottomAnchor constraintEqualToAnchor:bottomAnchor constant:0];

  NSArray* constraints = [NSArray arrayWithObjects:leftAnchorConstraint, rightAnchorConstraint, topAnchorConstraint, bottomAnchorConstraint, nil];
  // Sets the active property of each NSLayoutConstraint object to YES. The
  // constraints are installed in superview because that's the common ancestor
  // of the involved constraints.
  [NSLayoutConstraint activateConstraints:constraints];

  return constraints;
}


// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to the view of @a viewController that
/// specify that @a subview completely fills the area between the top and bottom
/// layout guide of @a viewController. Returns the constraints generated by this
/// method.
// -----------------------------------------------------------------------------
+ (NSArray*) fillAreaBetweenGuidesOfViewController:(UIViewController*)viewController
                                       withSubview:(UIView*)subview
{
  NSDictionary* viewsDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
                                   subview, @"subview",
                                   viewController.topLayoutGuide, @"topGuide",
                                   viewController.bottomLayoutGuide, @"bottomGuide",
                                   nil];
  NSArray* visualFormats = [NSArray arrayWithObjects:
                            @"H:|-0-[subview]-0-|",
                            @"V:[topGuide]-0-[subview]-0-[bottomGuide]",
                            nil];
  return [AutoLayoutUtility installVisualFormats:visualFormats
                                       withViews:viewsDictionary
                                          inView:viewController.view];
}

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a superview that specify that
/// @a subview is horizontally and vertically centered in @a superview. Returns
/// the constraints generated by this method.
// -----------------------------------------------------------------------------
+ (NSArray*) centerSubview:(UIView*)subview inSuperview:(UIView*)superview
{
  NSLayoutConstraint* constraint1 = [AutoLayoutUtility alignFirstView:subview
                                                       withSecondView:superview
                                                          onAttribute:NSLayoutAttributeCenterX
                                                     constraintHolder:superview];
  NSLayoutConstraint* constraint2 = [AutoLayoutUtility alignFirstView:subview
                                                       withSecondView:superview
                                                          onAttribute:NSLayoutAttributeCenterY
                                                     constraintHolder:superview];
  return [NSArray arrayWithObjects:constraint1, constraint2, nil];
}

// -----------------------------------------------------------------------------
/// @brief Adds an Auto Layout constraint to @a superview that specifies that
/// @a subview is centered in @a superview along the specified axis. Returns the
/// constraint generated by this method.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) centerSubview:(UIView*)subview
                          inSuperview:(UIView*)superview
                               onAxis:(UILayoutConstraintAxis)axis
{
  NSLayoutAttribute attribute;
  if (UILayoutConstraintAxisHorizontal == axis)
    attribute = NSLayoutAttributeCenterX;
  else
    attribute = NSLayoutAttributeCenterY;
  return [AutoLayoutUtility alignFirstView:subview
                            withSecondView:superview
                               onAttribute:attribute
                          constraintHolder:superview];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns two views @a firstView
/// and @a secondView on the attribute @a attribute. The constraint is added to
/// @a constraintHolder. Returns the constraint generated by this method.
///
/// Align means that the two views will have the same value for the specified
/// attribute. For instance, if @a attribute is NSLayoutAttributeLeft, then the
/// two views are left-aligned. A little less intuitive: If @a attribute is
/// NSLayoutAttributeWidth or NSLayoutAttributeHeight, then the two views have
/// the same width or height.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                           onAttribute:(NSLayoutAttribute)attribute
                      constraintHolder:(UIView*)constraintHolder
{
  return [AutoLayoutUtility alignFirstView:firstView
                            withSecondView:secondView
                               onAttribute:attribute
                              withConstant:0
                          constraintHolder:constraintHolder];
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns two views @a firstView
/// and @a secondView on the attribute @a attribute, with the alignment being
/// modified by @a constant. The constraint is added to @a constraintHolder.
/// Returns the constraint generated by this method.
///
/// Align means that the two views will have the same value for the specified
/// attribute, with @a constant added. For instance, if @a attribute is
/// NSLayoutAttributeLeft, then the two views are left-aligned, with
/// @a firstView additionally shifted to the right or left (depending on whether
/// @a constant is a positive or negative value). A little less intuitive: If
/// @a attribute is NSLayoutAttributeWidth or NSLayoutAttributeHeight, then
/// @a firstView has the same width or height as @a secondView, with @a constant
/// being added to the width or height.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
                           onAttribute:(NSLayoutAttribute)attribute
                          withConstant:(CGFloat)constant
                      constraintHolder:(UIView*)constraintHolder
{
  NSLayoutConstraint* constraint = [NSLayoutConstraint constraintWithItem:firstView
                                                                attribute:attribute
                                                                relatedBy:NSLayoutRelationEqual
                                                                   toItem:secondView
                                                                attribute:attribute
                                                               multiplier:1.0f
                                                                 constant:constant];
  [constraintHolder addConstraint:constraint];
  return constraint;
}

// -----------------------------------------------------------------------------
/// @brief Creates an Auto Layout constraint that aligns a view @a firstView
/// and @a secondView on the anchor specified by @a attribute. The anchor of
/// @a firstView is aligned with the anchor in the safe area layout guide of
/// @a secondView. The constraint is added to the closest common ancestor of
/// the two views. Returns the constraint generated by this method.
///
/// If one of the views is the superview of the other, then the constraint is
/// added to the superview.
///
/// Not all values of enumeration NSLayoutAttribute can be used. Returns @e nil
/// if @a attribute has an unsupported NSLayoutAttribute value.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) alignFirstView:(UIView*)firstView
                        withSecondView:(UIView*)secondView
           onSafeAreaLayoutGuideAnchor:(NSLayoutAttribute)attribute
{
  NSLayoutAnchor* firstViewAnchor;
  NSLayoutAnchor* secondViewAnchor;
  switch (attribute)
  {
    case NSLayoutAttributeLeft:
      firstViewAnchor = firstView.leftAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.leftAnchor;
      else
        secondViewAnchor = secondView.leftAnchor;
      break;
    case NSLayoutAttributeRight:
      firstViewAnchor = firstView.rightAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.rightAnchor;
      else
        secondViewAnchor = secondView.rightAnchor;
      break;
    case NSLayoutAttributeTop:
      firstViewAnchor = firstView.topAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.topAnchor;
      else
        secondViewAnchor = secondView.topAnchor;
      break;
    case NSLayoutAttributeBottom:
      firstViewAnchor = firstView.bottomAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.bottomAnchor;
      else
        secondViewAnchor = secondView.bottomAnchor;
      break;
    case NSLayoutAttributeLeading:
      firstViewAnchor = firstView.leadingAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.leadingAnchor;
      else
        secondViewAnchor = secondView.leadingAnchor;
      break;
    case NSLayoutAttributeTrailing:
      firstViewAnchor = firstView.trailingAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.trailingAnchor;
      else
        secondViewAnchor = secondView.trailingAnchor;
      break;
    case NSLayoutAttributeWidth:
      firstViewAnchor = firstView.widthAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.widthAnchor;
      else
        secondViewAnchor = secondView.widthAnchor;
      break;
    case NSLayoutAttributeHeight:
      firstViewAnchor = firstView.heightAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.heightAnchor;
      else
        secondViewAnchor = secondView.heightAnchor;
      break;
    case NSLayoutAttributeCenterX:
      firstViewAnchor = firstView.centerXAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.centerXAnchor;
      else
        secondViewAnchor = secondView.centerXAnchor;
      break;
    case NSLayoutAttributeCenterY:
      firstViewAnchor = firstView.centerYAnchor;
      if (@available(iOS 11.0, *))
        secondViewAnchor = secondView.safeAreaLayoutGuide.centerYAnchor;
      else
        secondViewAnchor = secondView.centerYAnchor;
      break;
    default:
      return nil;
  }

  NSLayoutConstraint* constraint = [firstViewAnchor constraintEqualToAnchor:secondViewAnchor constant:0];
  constraint.active = YES;

  return constraint;
}

// -----------------------------------------------------------------------------
/// @brief Adds an Auto Layout constraint to @a constraintHolder that causes
/// @a view to have the same width and height. If @a widthDependsOnHeight is
/// true the width auto layout attribute depends on the height auto layout
/// attribute, if @a widthDependsOnHeight is false the dependency relationship
/// is reversed. Returns the constraint generated by this method.
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) makeSquare:(UIView*)view
              widthDependsOnHeight:(bool)widthDependsOnHeight
                  constraintHolder:(UIView*)constraintHolder
{
  return [AutoLayoutUtility setAspectRatio:1.0
                             widthToHeight:widthDependsOnHeight
                                    ofView:view
                          constraintHolder:constraintHolder];
}

// -----------------------------------------------------------------------------
/// @brief Adds an Auto Layout constraint to @a constraintHolder that causes
/// @a view to have the aspect ratio specified by @a multiplier. If
/// @a widthToHeight is true the aspect ratio is width-to-height, if
/// @a widthToHeight is false the aspect ratio is height-to-width. Returns the
/// constraint generated by this method.
///
/// For a width-to-height aspect ratio, calculate the multiplier by dividing the
/// width by the height portion of the desired aspect ratio. For instance, if
/// the desired aspect ratio is 16:9, supply the result of 16 divided by 9 as
/// the value for @a multiplier.
///
/// For a width-to-height aspect ratio, if @a multiplier is greater than 1.0f
/// then @a view will be wider than high. If @a multiplier is less than 1.0f
/// then @a view will be higher than wide.
///
/// For a height-to-width aspect ratio, all of the above must be reversed.
///
/// If @a multiplier is 1.0f then @a view will be square, regardless of whether
/// @a widthToHeight is true or false.
///
/// @note The value of @a widthToHeight has a double meaning: In terms of Auto
/// Layout constraints, the value also describes the dependency relationship
/// between the width and the height layout attribute. For a width-to-height
/// aspect ratio (i.e. @a widthToHeight is true) the width attribute depends on
/// the height attribute. For a height-to-width aspect ratio, the height
/// attribute depends on the width attribute. If the Auto Layout subsystem is
/// unable to resolve dependencies, a potential solution might be to reverse the
/// dependency relationship (this might help even if you want @a view to be
/// square and @a widthToHeight has no actual meaning for the aspect ratio).
// -----------------------------------------------------------------------------
+ (NSLayoutConstraint*) setAspectRatio:(CGFloat)multiplier
                         widthToHeight:(bool)widthToHeight
                                ofView:(UIView*)view
                      constraintHolder:(UIView*)constraintHolder
{
  NSLayoutAttribute dependingAttribute;
  NSLayoutAttribute dependentAttribute;
  if (widthToHeight)
  {
    dependingAttribute = NSLayoutAttributeWidth;
    dependentAttribute = NSLayoutAttributeHeight;
  }
  else
  {
    dependingAttribute = NSLayoutAttributeHeight;
    dependentAttribute = NSLayoutAttributeWidth;
  }
  NSLayoutConstraint* constraint = [NSLayoutConstraint constraintWithItem:view
                                                                attribute:dependingAttribute
                                                                relatedBy:NSLayoutRelationEqual
                                                                   toItem:view
                                                                attribute:dependentAttribute
                                                               multiplier:multiplier
                                                                 constant:0.0f];
  [constraintHolder addConstraint:constraint];
  return constraint;
}

// -----------------------------------------------------------------------------
/// @brief Adds Auto Layout constraints to @a view for each visual format string
/// found in @a visualFormats. The views referred to by the visual format
/// strings must be present in @a viewsDictionary. Returns an array with all
/// constraints generated by this method.
// -----------------------------------------------------------------------------
+ (NSArray*) installVisualFormats:(NSArray*)visualFormats
                        withViews:(NSDictionary*)viewsDictionary
                           inView:(UIView*)view
{
  NSMutableArray* generatedConstraints = [NSMutableArray array];
  for (NSString* visualFormat in visualFormats)
  {
    NSArray* constraints = [NSLayoutConstraint constraintsWithVisualFormat:visualFormat
                                                                   options:0
                                                                   metrics:nil
                                                                     views:viewsDictionary];
    [view addConstraints:constraints];
    [generatedConstraints addObjectsFromArray:constraints];
  }
  return generatedConstraints;
}

// -----------------------------------------------------------------------------
/// @brief Returns the value used by Auto Layout as the default horizontal
/// spacing between sibling views. Example visual format string:
/// @"H:[view]-[view]"
// -----------------------------------------------------------------------------
+ (CGFloat) horizontalSpacingSiblings
{
  static CGFloat horizontalSpacingSiblings = -1.0f;
  if (horizontalSpacingSiblings < 0.0f)
    horizontalSpacingSiblings = [AutoLayoutUtility spacingForVisualFormatConstraint:@"H:[view]-[view]"];
  return horizontalSpacingSiblings;
}

// -----------------------------------------------------------------------------
/// @brief Returns the value used by Auto Layout as the default vertical spacing
/// between sibling views. Example visual format string: @"V:[view]-[view]"
// -----------------------------------------------------------------------------
+ (CGFloat) verticalSpacingSiblings
{
  static CGFloat verticalSpacingSiblings = -1.0f;
  if (verticalSpacingSiblings < 0.0f)
    verticalSpacingSiblings = [AutoLayoutUtility spacingForVisualFormatConstraint:@"V:[view]-[view]"];
  return verticalSpacingSiblings;
}

// -----------------------------------------------------------------------------
/// @brief Returns the value used by Auto Layout as the default horizontal
/// spacing between a view and its superview. Example visual format string:
/// @"H:|-[view]"
// -----------------------------------------------------------------------------
+ (CGFloat) horizontalSpacingSuperview
{
  static CGFloat horizontalSpacingSuperview = -1.0f;
  if (horizontalSpacingSuperview < 0.0f)
    horizontalSpacingSuperview = [AutoLayoutUtility spacingForVisualFormatConstraint:@"H:|-[view]"];
  return horizontalSpacingSuperview;
}

// -----------------------------------------------------------------------------
/// @brief Returns the value used by Auto Layout as the default vertical spacing
/// between a view and its superview. Example visual format string:
/// @"V:|-[view]"
// -----------------------------------------------------------------------------
+ (CGFloat) verticalSpacingSuperview
{
  static CGFloat verticalSpacingSuperview = -1.0f;
  if (verticalSpacingSuperview < 0.0f)
    verticalSpacingSuperview = [AutoLayoutUtility spacingForVisualFormatConstraint:@"V:|-[view]"];
  return verticalSpacingSuperview;
}

// -----------------------------------------------------------------------------
/// @brief Internal helper for the various horizontalSpacing* and
/// verticalSpacing* class methods.
///
/// @a visualFormat must describe a single relationship between two elements:
/// Either a view and its superview, or a view and a sibling view. The view
/// element(s) must always be named "view". Examples:
/// - View/superview relationship: "H:|-[view]"
/// - View/view relationship: "V:[view]-[view]"
///
/// The return value denotes the spacing between the two related elements.
// -----------------------------------------------------------------------------
+ (CGFloat) spacingForVisualFormatConstraint:(NSString*)visualFormat
{
  UIView* superview = [[[UIView alloc] initWithFrame:CGRectZero] autorelease];
  UIView* view = [[[UIView alloc] initWithFrame:CGRectZero] autorelease];
  [superview addSubview:view];
  view.translatesAutoresizingMaskIntoConstraints = NO;
  NSArray* constraints = [NSLayoutConstraint constraintsWithVisualFormat:visualFormat
                                                                 options:0
                                                                 metrics:nil
                                                                   views:NSDictionaryOfVariableBindings(view)];
  NSLayoutConstraint* constraint = constraints[0];
  return constraint.constant;
}

// -----------------------------------------------------------------------------
/// @brief Returns the spacing to use when placing elements inside a table view
/// cell content view; the spacing is the distance from the left or right edge
/// of the table view cell content view.
// -----------------------------------------------------------------------------
+ (CGFloat) horizontalSpacingTableViewCell
{
  static CGFloat horizontalSpacingTableViewCell = -1.0f;
  if (horizontalSpacingTableViewCell < 0.0f)
  {
    if ([LayoutManager sharedManager].uiType != UITypePhone)
    {
      UITableViewCell* cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"dummy"] autorelease];
      cell.textLabel.text = @"A";
      [cell layoutIfNeeded];
      horizontalSpacingTableViewCell = cell.textLabel.frame.origin.x;
    }
    else
    {
      // On the iPhone 6+ the above method to calculate the real value does not
      // work: The calculated value is 15, i.e. the same as on all other
      // devices, but when we look at the *REAL* spacing we see that on
      // iPhone 6+ it has increased to 20. Although hard-coding values is ugly,
      // we don't have any other choice :-( By basing our decision on the UIType
      // we hope to make this solution slightly more resilient: UITypePhone
      // hopefully covers other, future devices with wide screens, and these
      // hopefully behave the same as the iPhone 6+ and also use a larger
      // spacing.
      horizontalSpacingTableViewCell = 20;
    }
  }
  return horizontalSpacingTableViewCell;
}

// -----------------------------------------------------------------------------
/// @brief Returns the spacing to use when placing elements inside a table view
/// cell content view; the spacing is the distance from the top or bottom edge
/// of the table view cell content view.
// -----------------------------------------------------------------------------
+ (CGFloat) verticalSpacingTableViewCell
{
  // TODO Don't fake this, calculate the real value. Unfortunately we can't use
  // the same approach as in horizontalSpacingTableViewCell - with that approach
  // we would determine the distance of the text label from the top edge of the
  // content view, i.e. cell.textLabel.frame.origin.y. Unfortunately the value
  // of this is always 0 (zero). So instead we fake the real thing by returning
  // an approximate value.
  return [AutoLayoutUtility verticalSpacingSiblings];
}

@end
